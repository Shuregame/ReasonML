# ReasonML
## Что такое ReasonML?
Reason - это новый язык программирования, созданный людьми на Facebook. Более конкретно, Reason - это новый синтаксис языка OCaml. OCaml существует уже некоторое время (с 1996 года) и с годами превратилась в надежную и зрелую систему типов. Преимущества строго типизированной системы обсуждались, но в целом признаны хорошей практикой на арене Javascript. Большинство современных крупномасштабных приложений сегодня получили большую выгоду от наличия какой-либо формы проверки типов, будь то Flow, Typescript или ReasonML.

Reason - это не только статически типизированный, но и функциональный язык с такими понятиями, как неизменность и вывод типа, встроенными прямо в язык. Вам больше не нужно выходить за пределы своего набора инструментов для таких вещей, как ImmutableJS, Flow, Prettier, Lodash и т. Д. Все это поставляется из коробки как часть языка.


Reason может компилироваться для собственных целей, таких как iOS, Android, Windows или Linux, но более впечатляюще для разработчиков переднего плана, он может компилироваться для очистки читаемого Javascript.

Он также может конвертировать из OCaml в ReasonML.

Фича | Reason | Вывод javaScript
------------ | ------------- | -------------
String | "Hello" | "Hello"
Character | 'x' | "x"
Integer | 23, -23 | 23, -23
Сложение Float | 23.0 +. 1.0 | 23.0 + 1.0
Возведение Float | 2.0 ** 3.0 | Math.pow(3, 4)
List | [1, 2, 3] | [1, [2, [3, 0]]]
Array | [1, 2, 3] | [1, 2, 3]
Конкатенация строк | "Hello " ++ "world!" | "Hello " + "World"


## Что такое Bucklescript?
Bucklescript - это компилятор, который превращает код ReasonML в чистый читаемый код Javascript.
Опыт разработчика, использующего Bucklescript, просто фантастический, потому что он быстрый, очень быстрый. Компилятор оптимизирован для выполнения некоторых впечатляющих задач, включая добавочную компиляцию за миллисекунды, пока вы изменяете свой код, и мощный вывод типов.


Bucklescript также имеет мост под названием FFI (интерфейс с внешними функциями), который позволяет нам взаимодействовать со всей экосистемой NPM. Единственное, что нам нужно сделать для работы с существующим пакетом NPM - это использовать существующий пакет привязки или создать свой собственный, если он не существует.


Какова причина реагировать?
React, наконец, прошел полный цикл из своей альфа-реализации, которая была сделана в StandardML, языке того же семейства, что и ReasonML и OCaml. ReasonReact, конечно, является реализацией React в ReasonML. Как вы увидите, в React есть много узнаваемых шаблонов, хотя на этом пути были сделаны некоторые улучшения.


## Настройка и первая компиляция.
Существует несколько способов настройки нового проекта ReasonReact, один из которых - использование скрипта, похожего на create-реакции-приложение (https://github.com/reasonml-community/reason-scripts), который мы не будем рассматривать Вот. Я лично чувствую, что этот способ создания проекта слишком ограничен и запутывает многие внутренние работы, к которым мне нравится иметь доступ.

Вместо этого мы будем использовать Bucklescript для генерации нашего проекта.

Сначала нам нужно установить компилятор Buckscript:

![Image alt](https://github.com/Shuregame/ReasonML/blob/master/img1.png)

Если у вас установлена старая версия Bucklescript, рекомендуется удалить старую версию перед установкой новой.

После того, как это установлено, мы можем сгенерировать проект с разумной реакцией и перейти в новую папку:

![Image alt](https://github.com/Shuregame/ReasonML/blob/master/2.png)


Обратите внимание, что существует файл package.json, как и любой другой проект, основанный на npm. В нем вы видите, что устанавливаются webpack, реагирует и компилятор bsb.
Существует новый файл bsconfig.json, в котором хранятся параметры конфигурации для компилятора Bucklescript. В нем вы можете найти, где находятся исходные файлы, зависимости и какие суффиксы использовать для скомпилированного кода среди прочего. Вы можете узнать, что все эти настройки, проверив документы: https://bucklescript.github.io/docs/en/build-configuration#docsNav
Существует папка src /, содержащая код причины и файл index.hml.

![Image alt](https://github.com/Shuregame/ReasonML/blob/master/3.png)

Давайте установим все зависимости узла этого проекта.

![Image alt](https://github.com/Shuregame/ReasonML/blob/master/4.png)

Давайте скомпилируем их, запустив компилятор bsb вручную:

![Image alt](https://github.com/Shuregame/ReasonML/blob/master/5.png)

Теперь мы должны увидеть, что в папке src / были созданы новые файлы с суффиксом bs.js. Если вы откроете один из этих файлов, вы увидите, что это чистые файлы JavaScript, не более и не менее того. Это не только файлы javascript, но и читаемые файлы javascript. Вы также заметите папку lib /, которая была создана на верхнем уровне вашего проекта.

Эта папка будет содержать промежуточные файлы компиляции Ocaml, которые мы можем пока игнорировать.

Теперь нам нужно запустить веб-пакет для генерации js-пакета:

![Image alt](https://github.com/Shuregame/ReasonML/blob/master/6.png)

Теперь мы можем открыть файл index.html в нашей папке / build в вашем браузере и увидеть наш первый компонент Reason React.


![Image alt](https://github.com/Shuregame/ReasonML/blob/master/7.png)

## Улучшение опыта разработчика


Каким бы захватывающим это ни было, у нас все еще нет хорошего пользовательского опыта. Для начала нам нужно перезапустить компилятор Bucklescript и веб-пакет, чтобы любые изменения отображались на экране. Также было бы неплохо, если бы мы могли запустить приложение на webpack-сервере вместо того, чтобы открывать его прямо с диска. Окончательная заморозка будет в том случае, если мы начнем горячую перезагрузку, чтобы увидеть, как изменения нашего кода сразу же отражаются в браузере.


Мы можем начать с запуска компилятора Bucklescript с включенным флагом наблюдения, чтобы все наши изменения в файлах Reason были немедленно скомпилированы.

К счастью для нас, последняя версия этой темы проекта уже поставляется с установленным и готовым к работе webpack-dev-server.

Давайте запустим это:

![Image alt](https://github.com/Shuregame/ReasonML/blob/master/8.png)


Теперь давайте запустим компилятор Bucklescript, чтобы отслеживать изменения в файлах ReasonML. Убедитесь, что вы запускаете это в отдельном окне терминала.


![Image alt](https://github.com/Shuregame/ReasonML/blob/master/9.png)

Теперь вы можете зайти в браузер и загрузить приложение с: http: // localhost: 8000 /

Чтобы запустить горячую замену модуля, нам нужно внести пару изменений в файл webpack.config.js.

Сначала нам нужно изменить конфигурацию publicPath на ‘/‘, это позволит веб-пакетам использовать сохраненную в памяти версию файла index.html, а не ту, которая находится в папке / build. Теперь мы можем удалить эту папку, и это не имеет значения.

Второе изменение заключается в том, что нам нужно избавиться от строки inject: false в конфигурации HtmlWebpackPlugin. По умолчанию будет установлено значение true и мы сможем перезагрузить HTML при обнаружении изменений.

Обратите внимание, что нам не нужно добавлять горячее к истинному в настройках devServer по умолчанию, последняя версия webpack-dev-server будет иметь горячую перезагрузку.

<img src="https://github.com/Shuregame/ReasonML/blob/master/10.png width="48">

![Image alt](https://github.com/Shuregame/ReasonML/blob/master/10.png)

Убедитесь, что вы повторно запустили webpack-dev-server и затем попытаетесь изменить текст файла src / Index.re с «Hello» на «Bye». Приложение должно автоматически и мгновенно перезагрузиться в вашем браузере.

Теперь у вас есть полностью рабочая среда ReasonReact в комплекте с webpack-dev-server и горячей перезагрузкой. Обратите внимание, что большинство приведенных выше команд имеют ярлык package.json, который вы можете использовать через yarn или npm.
